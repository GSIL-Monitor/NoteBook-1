java

* public static void ... : 修饰静态方法，直接使用类名.方法名调用。

* StringBuffer（字符串缓冲区）: 创建内容和长度可变的字符串。

* foreach: 主要用于遍历数组或集合。  
　　for（元素类型t 元素变量x ：遍历对象obj）｛  
　　　　引用了x的java语句；　　　　  
　　　　｝

* Stream  
　List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);  
　number.parallesStream().forEach(out::println);  
　Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作。

* Lambda表达式。  
　　参考资料地址：https://blog.csdn.net/dd864140130/article/details/50603420

------
# Spring

* Spring常用注解：  
@Controller(value=" ") ,其中value为注入的bean的名字。  
@Service  
@Reposiory  
@Component  
@RestController：表示该Controller不返回视图，而仅返回数据。

------
# SprinvMVC
* SpringMVC常用注解：   
@RequestMapping(value=" ", method=" ")
------

# 前端部分

## HTML
* **\<div>**  定义文档中的分区或节，将文档分割成独立的、不同的部分。

* **\<script>** 标签用于定义客户端脚本，如JavaScript。

* **\<tr>** 定义**HTML表格**中的行。其中包含一个或多个**th**或**td**元素。
```html
    <tr>
        <th>***</th>                     //<th>,表头单元格-包含表头信息。
    </tr>
    <tr>
        <td>***</td>                     //<td>, 标准单元格-包含数据。
    </tr>
```

* **\<ul>** 无序HTML列表。

* **\<li>** 定义列表项目，可用在有序列表（\<ol>）和无序列表（\<ul>）中。

* **\<a>** 超链接。

* **\<i>** 文本斜体效果显示。

* **\<span>** 用于对文档中的行内元素进行组合，被<span>元素包含的文本，可以使用CSS定义式样，或者使用JavaScript进行操作。

## CSS

## JavaScript

* zTree数据格式。 参考资料地址：http://www.cnblogs.com/shinhwazt/p/5828031.html

zTree在使用JSON数据时，由两种数据格式供我们使用，分别是标准数据模式和简单数据模式

标准的数据模式为：

      var nodes = {name:"第一层级",children:[{name:"第二层级",id:2,childred:[{}]}],id:1}  

标准的数据模式的数据是一个JSON对象，立面的name会用作显示节点的名称，children会用作第一个阶段的子节点，children里面是一个个的对象，这些对象也是第一层级的格式，层层嵌套最终形成一个数据集合用作加载tree。name和children是必须的属性，其他的属性根据我们的实际需求具体添加。

　　简单数据模式：

    var nodes = [{name:"第一层级",id:0,pId:null},{name:"第二层级",id:1,pId:0},{name:"第一层级",id:2,pId:0}]
 简单数据模式的数据是一个数组对象，数组中的每一个对象都必须包括name,id,pid，name用作显示当前的节点名称,id表示当前的节点的唯一标识可用来做关联父级节点的桥梁，pid也是用来做父子节点的桥梁的，在默认情况下如果pid为null则当前的这个对象表示是tree的顶层节点。其他的属性根据我们的实际需求可以自行添加。


## jQuery
```javascript
//对id为EVENTLEVEL的组件赋值为value的值
$("#EVENTLEVEL").val(value); 

//对id为EVENTLEVEL的组件的下一级包含的a组件的span组件的text赋值为aaaaa。
$("#EVENTLEVEL").next().find("a span").text("aaaaa")       
```
* .trigger() 触发被选元素的指定事件类型。

* .bind() 为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。

* .attr() 设置或返回被选元素的属性值

* .data() 向被选元素附加数据，或者从被选元素获取数据
------

## JSON

以下内容随便写的：

```json
myObj = {
    "name":"网站",
    "num":3,
    "sites": [
        { "name":"Google", "info":[ "Android", "Google 搜索", "Google 翻译" ] },
        { "name":"Runoob", "info":[ "菜鸟教程", "菜鸟工具", "菜鸟微信" ] },
        { "name":"Taobao", "info":[ "淘宝", "网购" ] }
    ]
}
```

```json
myObj.sites[1] = { "name":"Google", "info":[ "Android", "Google 搜索", "Google 翻译" ] 
```

### 通过json数据创建JavaScript数据：

```json
var obj = JSON.parse('{ "name":"runoob", "alexa":10000, "site":"www.runoob.com" }');
```

# J2EE

## JSP
### 跳转
* \<jsp:forword paga=" URL ">，URL是在当前JSP对象或者Servlet对象中去调用目标文件对应的对象，相当于方法调用,因此浏览器中URL的地址还是显示原JSP对象的页面地址。

### JSTL

JSTL JSP Standard Tag Library 标准标签库。

JSTL允许开发人员可以像使用HTML标签一样在JSP中开发Java功能。

------
# Eclipse

## 快捷键
* Ctrl + Shift + l: 提示eclipse快捷键的快捷键。

* Ctrl + Shift + F6: 编辑页之间切换。

* tab: 向右缩进4个空格。

* shift + tab:向左缩进4个空格。

* Ctril + Alt +　D: Restart in Debug

* Ctril + Alt +　R: Restart

* Shift +　Alt +　S： 快速生成get/set方法

## 设置相关

------
# chrome 开发者工具
* F12: 打开开发者工具。

* Ctrl + F5: 强制刷新。（用于去缓存）

* Elements: 元素面板，使用“元素”面板可以通过自由操纵DOM和CSS来重演网站的布局和设计。

* Console：控制台面板，在开发期间，可以使用控制台面板记录诊断信息。或者使用它作为      shell，在页面上与JavaScript交互。

* Sources：源代码面板，用于断点调试JavaScript。或者通过Workspaces连接本地文件，使用开发者工具实时编辑。

* Network：网络面板，用于了解请求和下载的资源文件，并优化网页加载性能。

* Ctrl+O：在开发者工具下，寻找要搜寻的sources文件，可以在此文件进行调试。

* 

------

# java外部包

## org.apache.log4j.Logger

### 配置文件

配置文件位置：log4i.propertes

可以设置级别：debug>info>error

​debug：显示debug、info、error

info：显示info、erro

------
# Mysql

## 创建和操纵表

### 删除表

```mysql
DROP TABLE tablename;
```

## 存储过程

存储过程就是为以后使用而保存的一条或多条sql语句

## Mysql分区

**目的：** 在特定的SQL操作中减少数据读写的总量以缩减sql语句的响应时

### 分区类型

#### 水平分区 

* RANGE：基于属于一个给定连续区间的列值，把多行分配给分区

* LIST：基于列值匹配一个离散值集合中的某个值来进行选择

* HASH/LINEAR HASH：基于用户定义的表达式的返回值来选择分区，改表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含Mysql中有效的、产生非负整数值的任何表达式(表达式返回值必须是整数)*

* KEY：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
* Composite（复合分区）：以上四种分区的组合

#### 垂直分区

### 分区实例
**查看数据库是否支持分区：** （返回yes表示支持）

```mysql
SHOW VARIABLES LIKE "%partition%"
```

**建立分区: **

* RANGE分区

  ```mysql
  create table user(
  id int primary key auto_increment,
  username varchar(20) ,
  age int
  )
  partition by range(id)
  (
  partition p1 values less than(100),
  partition p2 values less than(200),
  partition p3 values less maxvalue
  );
  ```

* LIST分区

  ```mysql
  create table user(
  id int primary key auto_increment,
  username varchar(20) ,
  age int,
  sex int,   -- 0：女 1：男 2：保密 3：雌雄同体
  primary key(id,sex)
  )
  partition by list(sex)
  (
  partition p1 values in (0),
  partition p2 values in (1),
  partition p3 values in (2,3)
  )
  ```

* HASH分区（放到哪个分区中由数据库决定，可以理解为通过计算hash值，将数据平分的放到几个分区中）

  ```mysql
  create table user(
  id int primary key auto_increment,
  username varchar(20) ,
  age int,
  sex int,   -- 0：女 1：男 2：保密
  primary key (id,sex)
  )
  partition by hash(sex)
  partitions 3;
  ```

* KEY分区

  ```mysql
  create table user(
  id int primary key auto_increment,
  username varchar(20) ,
  age int,
  sex int,   -- 0：女 1：男 2：保密
  primary key(id,sex)
  )
  partition by key(sex)
  partitions 3;
  ```

* Composite（复合分区）

  复合分区就是在已经建立的分区上再建立分区，类似于HTML中的树结构

  *（MySQL允许在range和list的分区上再进行hash和key的子分区）*

  **注意：**

  1. 如果一个分区中创建了子分区，其他分区也要有子分区

  2. 如果创建了了分区，每个分区中的子分区数必有相同

  3. 同一分区内的子分区，名字不相同，不同分区内的子分区名子可以相同

  ```mysql
  create table user(
  id int  auto_increment,
  username varchar(20) ,
  age int,
  sex int,   -- 0：女 1：男 2：保密
  primary key(id,sex)
  )
  partition by range(id)
  subpartition by hash(sex)
  subpartitions 3
  (
  partition p1 value less than (200),
  partition p2 value less than maxvalue
  );
  ```

  以上，建立2和range分区，然后再range分区的基础上建立了3个hash分区，分区的数量为：
  $$
  2*3=6
  $$






**删除分区：**

*(不能删除HASH或者KEY分区)*

*注意：*在删除分区时，会将该分区下的数据同时删除

```mysql
alter table user drop partition p1; 
alter table user drop partition p1,p2;
```

**增加分区：** 

*（与建表时增加分区一样）*

```mysql
alter table user add partition (partition p4 values less than (300));
alter table user add partition (partition p4 value in (3));
```

**分解分区：** 

*（分区分解不会丢失数据）*

```mysql
alter table user reorganize partition p1 into
(
partition p1 values less than (50),
partition p4 values less than (100)
)
```

**合并分区：**

```mysql
alter table user reorganize partition p1,p4 into(partition p1 values less than (100));
```

**删除所有分区：**

```mysql
alter table user remove partitioing;
```

***剩余的还有：重建、优化、分析、检查分区。***

### 增删改查

分区对数据库的使用来说是透明的，因此有分区的表的增删改查与无分区的表的增删改查方式一致

### 自动分区

Mysql不能自动创建分区，需要使用Mysql event事件的方式自动创建分区

首先定义一个存储过程，然后在一定的条件下执行存储过程，能实现自动创建分区

1. 创建表

   ```mysql
   CREATE TABLE `test1` (
     `id` char(32) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '自增主键(guid)',
     `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
     `partition_key` int(8) NOT NULL COMMENT '分区键(格式:yyyyMMdd)',
     PRIMARY KEY (`id`,`partition_key`),
     UNIQUE KEY `id_UNIQUE` (`id`,`partition_key`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
   PARTITION BY RANGE (partition_key)
   (PARTITION p0 VALUES LESS THAN (20180619) ENGINE = InnoDB,
    PARTITION p20180619 VALUES LESS THAN (20180620) ENGINE = InnoDB,
    PARTITION p20180621 VALUES LESS THAN (20180622) ENGINE = InnoDB,
    PARTITION p20180622 VALUES LESS THAN (20180623) ENGINE = InnoDB,
    PARTITION p20180623 VALUES LESS THAN (20180624) ENGINE = InnoDB);　
   ```

2. 创建分区的存储过程

   ```mysql
   DELIMITER $$           #将';'临时替换为'$$'
   USE 'demo' $$          #demo为表存在的数据库名
   DROP PROCEDURE IF EXISTS 'creat_partition_by_day' $$   #creat_partition_by_day为存储过程
   CREATE PROCEDURE 'creat_partition_by_day' (IN_SCHEMANAME VARDHAR(64), IN_TABLENAME VARCHAR(64))                             #IN_SCHEMANAME和IN_TABLENAME为输入参数
   BEGIN
   	#当前日期存在的分区的个数
   	DECLARE ROWS_CNT INT UNSIGNED;  #DECLARE在复合语句中声明变量，UNSIGNED禁用负数
   	#目前日期，为当前日期的后一天
   	DECLARE TARGET_DATE TIMESTAMP;  #TIMESTAMP时间戳，唯一的表示某一时刻的时间
   	#分区的名称
   	DECLARE PARTITIONNAME VARCHAR(9);
       #当前分区名称的分区值上限，即为 PARTITIONNAME + 1
       DECLARE PARTITION_ADD_DAY VARCHAR(9);
       SET TARGET_DATE = NOW() + INTERVAL 1 DAY;     #SET用于赋值操作
       SET PARTITIONNAME = DATE_FORMAT( TARGET_DATE, 'p%Y%m%d' );
       SET TARGET_DATE = TARGET_DATE + INTERVAL 1 DAY;
       SET PARTITION_ADD_DAY = DATE_FORMAT( TARGET_DATE, '%Y%m%d' );
       SELECT COUNT(*) INTO ROWS_CNT FROM information_schema.partitions
       WHERE table_schema = IN_SCHEMANAME AND table_name = IN_TABLENAME AND 			partition_name = PARTITIONNAME;
       IF ROWS_CNT = 0 THEN
           SET @SQL = CONCAT( 'ALTER TABLE `', IN_SCHEMANAME, '`.`', IN_TABLENAME, '`',
           ' ADD PARTITION (PARTITION ', PARTITIONNAME, " VALUES LESS THAN (",
               PARTITION_ADD_DAY ,") ENGINE = InnoDB);" );
           PREPARE STMT FROM @SQL;
           EXECUTE STMT;
           DEALLOCATE PREPARE STMT;
        ELSE
          SELECT CONCAT("partition `", PARTITIONNAME, "` for table `",IN_SCHEMANAME, ".", IN_TABLENAME, "` already exists") AS result;
        END IF;
   END$$
   DELIMITER ;
   ```

3. 数据库执行定时任务（每小时执行一次）

   ```mysql
   DELIMITER $$
   #该表所在的数据库名称
   USE `demo`$$
   CREATE EVENT IF NOT EXISTS `daily_generate_partition`
   ON SCHEDULE EVERY 1 hour   #执行周期，还有天、月等等
   STARTS '2018-06-20 00:00:00'
   ON COMPLETION PRESERVE
   ENABLE
   COMMENT 'Creating partitions'
   DO BEGIN
       #调用刚才创建的存储过程，第一个参数是数据库名称，第二个参数是表名称
       CALL datacollectcenter.create_partition_by_day('demo','test1');
   END$$
   DELIMITER ;
   ```

**根据时间进行自动分区的实例**

> https://blog.csdn.net/Guns_NRoses/article/details/53083053

## mysql索引







